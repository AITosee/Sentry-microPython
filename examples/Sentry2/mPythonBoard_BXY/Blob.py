import timeimport randomfrom Sentry import *from mpython import *from machine import UARTuart1 = UART(1, baudrate=57600, tx=Pin.P14, rx=Pin.P13)sentry = Sentry2(0x60)random.seed(time.ticks_cpu())# 自定义函数def UART():  global my_variable, key_N, key_P, key_T, key_H, key_A, key_B, param_set, i, I2C, index, num, j  sentry.begin(uart1)def I2C():  global my_variable, key_N, key_P, key_T, key_H, key_A, key_B, param_set, i, I2C, index, num, j  sentry.begin(i2c)def Key_Operation():  global my_variable, key_N, key_P, key_T, key_H, key_A, key_B, param_set, i, I2C, index, num, j  if (param_set == 1):    oled.fill_rect(0, (2-1)*16, 128, 16, 0)    oled.fill_rect(0, (3-1)*16, 128, 16, 0)    oled.fill_rect(0, (4-1)*16, 128, 16, 0)    oled.show()    Key_A()    Key_B()    oled.DispChar("Operation OK!", 0, (2-1)*16, 1)    oled.show()    time.sleep(0.5)    oled.fill_rect(0, (2-1)*16, 128, 16, 0)    oled.show()    param_set = 0def Key_A():  global my_variable, key_N, key_P, key_T, key_H, key_A, key_B, param_set, i, I2C, index, num, j  if (key_A == 1):    key_A = 0    index = (random.randint(1, 6))    oled.DispChar((str(index)), 112, 0, 1)    oled.show()    sentry.SetParamNum(sentry2_vision_e.kVisionBlob,index)    i = 1    for index in range(index):      if (i == 1):        sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorYellow],1)      if (i == 2):        sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorBlue],2)      if (i == 3):        sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorGreen],3)      if (i == 4):        sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorRed],4)      if (i == 5):        sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorWhite],5)      if (i == 6):        sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorBlack],6)      i = (i + 1)      time.sleep(0.1)def Key_B():  global my_variable, key_N, key_P, key_T, key_H, key_A, key_B, param_set, i, I2C, index, num, j  if (key_B == 1):    key_B = 0    sentry.SetParamNum(sentry2_vision_e.kVisionBlob,1)    index = (random.randint(1, 6))    oled.DispChar((str(index)), 112, 0, 1)    oled.show()    if (index == 1):      sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorYellow],1)    if (index == 2):      sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorBlue],1)    if (index == 3):      sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorGreen],1)    if (index == 4):      sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorRed],1)    if (index == 5):      sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorWhite],1)    if (index == 6):      sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 10, 10, color_label_e.kColorBlack],1)def Result_Dispaly():  global my_variable, key_N, key_P, key_T, key_H, key_A, key_B, param_set, i, I2C, index, num, j  if (param_set == 0):    # Sentry2不主动返回检测识别结果，需要主控板发送指令进行读取。读取的流程：首先读取识别结果的数量，接收到指令后，Sentry2会刷新结果数据，如果结果数量不为零，那么主控再发送指令读取结果的相关信息。请务必按此流程构建程序。    num = (sentry.GetValue(sentry2_vision_e.kVisionBlob, sentry_obj_info_e.kStatus))    i = 1    for index in range(num):      if (sentry.GetValue(sentry2_vision_e.kVisionBlob,sentry_obj_info_e.kLabel,i)==color_label_e.kColorBlack):        oled.DispChar((str("Blob#") + str((str((str(i))) + str(": Black")))), 0, (2-1)*16, 1)      if (sentry.GetValue(sentry2_vision_e.kVisionBlob,sentry_obj_info_e.kLabel,i)==color_label_e.kColorWhite):        oled.DispChar((str("Blob#") + str((str((str(i))) + str(": White")))), 0, (2-1)*16, 1)      if (sentry.GetValue(sentry2_vision_e.kVisionBlob,sentry_obj_info_e.kLabel,i)==color_label_e.kColorRed):        oled.DispChar((str("Blob#") + str((str((str(i))) + str(": Red")))), 0, (2-1)*16, 1)      if (sentry.GetValue(sentry2_vision_e.kVisionBlob,sentry_obj_info_e.kLabel,i)==color_label_e.kColorGreen):        oled.DispChar((str("Blob#") + str((str((str(i))) + str(": Green")))), 0, (2-1)*16, 1)      if (sentry.GetValue(sentry2_vision_e.kVisionBlob,sentry_obj_info_e.kLabel,i)==color_label_e.kColorBlue):        oled.DispChar((str("Blob#") + str((str((str(i))) + str(": Blue")))), 0, (2-1)*16, 1)      if (sentry.GetValue(sentry2_vision_e.kVisionBlob,sentry_obj_info_e.kLabel,i)==color_label_e.kColorYellow):        oled.DispChar((str("Blob#") + str((str((str(i))) + str(": Yellow")))), 0, (2-1)*16, 1)      oled.DispChar((str("x=") + str((sentry.GetValue(sentry2_vision_e.kVisionBlob,sentry_obj_info_e.kXValue,i)))), 0, 32, 1)      oled.DispChar((str("y=") + str((sentry.GetValue(sentry2_vision_e.kVisionBlob,sentry_obj_info_e.kYValue,i)))), 64, 32, 1)      oled.DispChar((str("w=") + str((sentry.GetValue(sentry2_vision_e.kVisionBlob,sentry_obj_info_e.kWidthValue,i)))), 0, 48, 1)      oled.DispChar((str("h=") + str((sentry.GetValue(sentry2_vision_e.kVisionBlob,sentry_obj_info_e.kHeightValue,i)))), 64, 48, 1)      oled.show()      oled.fill_rect(0, (2-1)*16, 128, 16, 0)      oled.fill_rect(0, (3-1)*16, 128, 16, 0)      oled.fill_rect(0, (4-1)*16, 128, 16, 0)      oled.show()      i = (i + 1)# 事件回调函数def on_button_a_down(_):  time.sleep_ms(10)  if button_a.value() == 1: return  global param_set  global key_A  param_set = 1  key_A = 1def on_button_b_down(_):  time.sleep_ms(10)  if button_b.value() == 1: return  global param_set  global key_B  param_set = 1  key_B = 1button_a.irq(trigger=Pin.IRQ_FALLING, handler=on_button_a_down)button_b.irq(trigger=Pin.IRQ_FALLING, handler=on_button_b_down)num = 0index = 0i = 0j = 0key_A = 0key_B = 0param_set = 0# 等待Sentry2完成操作系统的初始化。此等待时间不可去掉，避免出现Sentry2尚未初始化完毕主控器已经开发发送指令的情况time.sleep(2)I2C()# 算法的默认参数，初始化时可以省略sentry.SetParamNum(sentry2_vision_e.kVisionBlob,1)sentry.SetParam(sentry2_vision_e.kVisionBlob,[0, 0, 3, 4, color_label_e.kColorRed],1)# 1、色块检测算法可以同时设置6组参数（UNO因自身硬件资源限制，最多只可设置5组参数），如果每组参数对应1种颜色，则可以同时检测6种颜色的色块；# 2、算法默认识别准确度为“均衡”；可以通过摇杆设置为“准确”与“灵敏”模式，# 3、算法默认每种颜色只输出1个结果。“灵敏”与“均衡”模式下最多每种颜色5个结果，但总的输出结果不超过25个，可以通过摇杆设置每种颜色的最大输出数量。（UNO因自身硬件资源限制，同时最多只可接收5组检测结果）# 4、设置为“准确”模式，即使视野内存在多个满足条件的色块，算法只输出1个结果，选定哪块色块依赖算法内部的判断标准；# 5、算法说明# https://tosee.readthedocs.io/zh/latest/Sentry2/Vision/index.html#chapter-vision-blob-index# 6、参考视频# https://www.bilibili.com/video/BV1y94y1677G/?spm_id_from=333.1387.upload.video_card.click&vd_source=a6a4a13d17ed26ee248472534a8ec3cc# https://www.bilibili.com/video/BV1KM411C73u/?spm_id_from=333.1387.upload.video_card.click&vd_source=a6a4a13d17ed26ee248472534a8ec3cc# 7、环境光对颜色识别与色块检测算法的影响极大：过亮会导致过曝，识别到的颜色均为白色；过暗会导致识别的颜色均为黑色。这两种算法在使用时注意以下几点：# a.环境过亮时，降低曝光时间在一定程度上可以缓解；最有效的方法是降低环境光亮度以及避免采用易反光的材料做为地图或者目标物体；# b.环境过暗时，增加曝光时间在一定程度上可以缓解，但会增加算法检测识别的时间；最有效的方法是进行补光，Sentry2摄像头两侧的LED灯“检测到”与“未检测到”两种情况均设置为白光并且亮度调到最大值可以作为补光灯使用；# c.当目标物体的颜色较淡（反光或者物体自身原因）时，可以增加成像的饱和度；# d.出厂默认的“自动”白平衡模式可以满足多数应用需求；# 存在大面积单色（非白色）区域，近距离识别颜色时，图像会发生偏色问题，可以通过摇杆操作或者发送代码设置白平衡模式为“锁定”，操作时需要将sentry2对准白色面，距离10-20cm；# 如果通过代码修改白平衡模式，命令发出后，延时至少500ms，等待设置生效；# 设置白平衡为“锁定”模式并且经过白平衡校正操作，重启Sentry2参数依然有效；如果环境光发生改变，需要重新执行白平衡锁定操作。## “设置LED灯光颜色”与“摄像头设置”请参考如下资料# https://tosee.readthedocs.io/zh/latest/Sentry2/Hardware/index.html#section-6# 8、正常使用时，应由主控器发送指令控制Sentry2算法的开启与关闭，而非通过摇杆手动进行操作；# 9、如需Sentry2启动后，自行运行某种算法，可以在开启算法后，通过设置“寄存器”->“保存当前值”实现。# 设置寄存器# https://tosee.readthedocs.io/zh/latest/Sentry2/Hardware/index.html#section-3sentry.VisionBegin(sentry2_vision_e.kVisionBlob)oled.DispChar("Algo: Blob", 0, 0, 1)oled.DispChar("index: ", 64, 0, 1)oled.DispChar((str(index)), 112, 0, 1)oled.show()while True:  Key_Operation()  Result_Dispaly()