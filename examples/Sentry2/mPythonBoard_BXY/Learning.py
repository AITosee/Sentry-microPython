import timefrom Sentry import *from mpython import *from machine import UARTuart1 = UART(1, baudrate=57600, tx=Pin.P14, rx=Pin.P13)sentry = Sentry2(0x60)# 自定义函数def UART():  global my_variable, key_A, key_B, param_set, ID, num, key_H, key_Y, key_N, i  sentry.begin(uart1)def Key_Operation():  global my_variable, key_A, key_B, param_set, ID, num, key_H, key_Y, key_N, i  if (param_set == 1):    param_set = 0    Button_A()    Button_B()    oled.fill_rect(48,48,16,16,0)    oled.show()    time.sleep(0.2)    oled.DispChar((str(ID)), 48, 48, 1)    oled.DispChar("Operation Done", 0, (2-1)*16, 1)    oled.show()    time.sleep(0.2)    oled.fill_rect(0, (2-1)*16, 128, 16, 0)    oled.show()def Result_Display():  global my_variable, key_A, key_B, param_set, ID, num, key_H, key_Y, key_N, i  i = 1  # Sentry2不会主动返回结果信息，需要主控器发送指令进行读取。首先要读取结果的数量，此时算法会自动更新识别或者检测的信息，如果结果不为零，再读取其他数据。 编写程序时请务必遵循本流程框架。  for index in range((sentry.GetValue(sentry2_vision_e.kVisionLearning, sentry_obj_info_e.kStatus))):    # 深度学习算法返回的xywh值为固定值，无实际意义，无需读取处理    oled.DispChar((str("ID=") + str((sentry.GetValue(sentry2_vision_e.kVisionLearning,sentry_obj_info_e.kLabel,i)))), 0, (2-1)*16, 1)    oled.show()    time.sleep(0.2)    oled.fill_rect(0, (2-1)*16, 128, 16, 0)    oled.show()    time.sleep(0.2)    i = (i + 1)def I2C():  global my_variable, key_A, key_B, param_set, ID, num, key_H, key_Y, key_N, i  sentry.begin(i2c)def Button_A():  global my_variable, key_A, key_B, param_set, ID, num, key_H, key_Y, key_N, i  if (key_A == 1):    key_A = 0    oled.DispChar("Focus on the object", 0, (2-1)*16, 1)    oled.show()    num = 3    for index in range(3):      oled.DispChar((str(num)), 0, (3-1)*16, 1)      oled.show()      time.sleep(1)      num = (num - 1)    oled.fill_rect(0, (2-1)*16, 128, 16, 0)    oled.fill_rect(0, (3-1)*16, 128, 16, 0)    oled.show()    time.sleep(0.2)    oled.DispChar("Saving...", 0, (2-1)*16, 1)    # 参数5写入100表示执行物体学习操作；    # 参数组值为当前激活的存储档位；    sentry.SetParam(sentry2_vision_e.kVisionLearning,[0, 0, 0, 0, 100],ID)    ID = (ID + 1)    if (ID > 15):      ID = 1def Button_B():  global my_variable, key_A, key_B, param_set, ID, num, key_H, key_Y, key_N, i  if (key_B == 1):    key_B = 0    ID = (ID - 1)    if (1 > ID):      ID = 15    # 参数5写入0表示执行数据删除操作    sentry.SetParam(sentry2_vision_e.kVisionLearning,[0, 0, 0, 0, 0],ID)# 事件回调函数def on_button_a_down(_):  time.sleep_ms(10)  if button_a.value() == 1: return  global param_set  global key_A  param_set = 1  key_A = 1def on_button_b_down(_):  time.sleep_ms(10)  if button_b.value() == 1: return  global param_set  global key_B  param_set = 1  key_B = 1button_a.irq(trigger=Pin.IRQ_FALLING, handler=on_button_a_down)button_b.irq(trigger=Pin.IRQ_FALLING, handler=on_button_b_down)param_set = 0key_A = 0key_B = 0key_Y = 0key_N = 0key_H = 0num = 0ID = 1i = 0# 等待Sentry2完成操作系统的初始化。此等待时间不可去掉，避免出现Sentry2尚未初始化完毕主控器已经开发发送指令的情况time.sleep(2)I2C()# 1、sentry2消费版可以学习15个物体，企业版可以学习25个物体；除了可以通过摇杆学习外，还可以参考本例程，通过自定义的指令进行操作；# 2、为了取得较好的识别效果，学习时的场景（包括但不限背景、灯光、角度等）请与实际使用的场景保持一致或者比较相似；# 3、如果需要在较大的范围内多个角度下均能检测到某个物体，那么需要在不同距离处的不同角度下学习该物体，存储的ID值分别为ID1...IDn，那么使用时，只要获取的label值为上述ID系列中的一个，即可判定检测到目标物体；# 如果上述操作仍无法满足需求，那么请烧录sentry2mv固件，自行采集数据训练模型# https://tosee.readthedocs.io/zh/latest/Sentry2/Sentry2MV/index.html# 4、算法文档# https://tosee.readthedocs.io/zh/latest/Sentry2/Vision/index.html#chapter-vision-learning-index# 5、参考视频# https://www.bilibili.com/video/BV1n84y1C7yj/?spm_id_from=333.1387.upload.video_card.click&vd_source=a6a4a13d17ed26ee248472534a8ec3cc# https://www.bilibili.com/video/BV1Ej411B7Up/?spm_id_from=333.1387.upload.video_card.click&vd_source=a6a4a13d17ed26ee248472534a8ec3cc# 6、正常使用时，应由主控器发送指令控制Sentry2算法的开启与关闭，而非通过摇杆手动进行操作；# 7、如需Sentry2启动后，自行运行某种算法，可以在开启算法后，通过设置“寄存器”->“保存当前值”实现。# 设置寄存器# https://tosee.readthedocs.io/zh/latest/Sentry2/Hardware/index.html#section-3sentry.VisionBegin(sentry2_vision_e.kVisionLearning)oled.DispChar("Algo: Learning", 0, (1-1)*16, 1)oled.DispChar("index=", 0, (4-1)*16, 1)oled.DispChar((str(ID)), 48, 48, 1)oled.DispChar("Initializaiton OK", 0, (2-1)*16, 1)oled.show()time.sleep(0.2)oled.fill_rect(0, (2-1)*16, 128, 16, 0)oled.show()while True:  Key_Operation()  Result_Display()