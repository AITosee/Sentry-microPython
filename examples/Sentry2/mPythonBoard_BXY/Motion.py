import timefrom Sentry import *from mpython import *from machine import UARTuart1 = UART(1, baudrate=57600, tx=Pin.P14, rx=Pin.P13)sentry = Sentry2(0x60)brightness=9# 自定义函数def UART():  global my_variable, x, y  sentry.begin(uart1)def I2C():  global my_variable, x, y  sentry.begin(i2c)def Result_Display():  global my_variable, x, y  # Sentry2不主动返回检测识别结果，需要主控板发送指令进行读取。读取的流程：首先读取识别结果的数量，接收到指令后，Sentry2会刷新结果数据，如果结果数量不为零，那么主控再发送指令读取结果的相关信息。请务必按此流程构建程序。  if ((sentry.GetValue(sentry2_vision_e.kVisionMotionDetect, sentry_obj_info_e.kStatus)) > 0):    rgb[1] = (255*brightness//9, 0*brightness//9, 0*brightness//9)    rgb.write()    # 因为只能够检测1个运动物体，所以只需读取结果1的信息    x = (round((((sentry.GetValue(sentry2_vision_e.kVisionMotionDetect,sentry_obj_info_e.kXValue,1)) * 1.23) - 4)))    # 结果的w与h值为固定值，无实际意义，故无需读取    y = (round((((sentry.GetValue(sentry2_vision_e.kVisionMotionDetect,sentry_obj_info_e.kYValue,1)) * 0.64) - 4)))    oled.rect(x,y,9,9,1)    oled.show()    time.sleep(0.1)    oled.rect(x,y,9,9,0)    oled.show()    rgb[1] = (0*brightness//9, 0*brightness//9, 0*brightness//9)    rgb.write()    time.sleep(0.1)x = 0y = 0time.sleep(2)I2C()# 1、sentry2企业版专有算法；# 2、算法说明# https://tosee.readthedocs.io/zh/latest/Sentry2/Vision/index.html#chapter-vision-motion-index# 3、使用时需要固定好sentry2，避免晃动，出现误报；# 4、正常使用时，应由主控器发送指令控制Sentry2算法的开启与关闭，而非通过摇杆手动进行操作；# 5、如需Sentry2启动后，自行运行某种算法，可以在开启算法后，通过设置“寄存器”->“保存当前值”实现。# 设置寄存器# https://tosee.readthedocs.io/zh/latest/Sentry2/Hardware/index.html#section-3sentry.VisionBegin(sentry2_vision_e.kVisionMotionDetect)rgb[1] = (51*brightness//9, 204*brightness//9, 0*brightness//9)rgb.write()while True:  Result_Display()