import timefrom Sentry import *from mpython import *from machine import UARTuart1 = UART(1, baudrate=57600, tx=Pin.P14, rx=Pin.P13)sentry = Sentry2(0x60)brightness=9# 自定义函数def UART():  global my_variable, row, column, x, y, i, j, index, Paramset_Sel, Param_Set, num, Key_B  sentry.begin(uart1)def I2C():  global my_variable, row, column, x, y, i, j, index, Paramset_Sel, Param_Set, num, Key_B  sentry.begin(i2c)def Result_Display():  global my_variable, row, column, x, y, i, j, index, Paramset_Sel, Param_Set, num, Key_B  # Sentry2不主动返回检测识别结果，需要主控板发送指令进行读取。读取的流程：首先读取识别结果的数量，接收到指令后，Sentry2会刷新结果数据，如果结果数量不为零，那么主控再发送指令读取结果的相关信息。请务必按此流程构建程序。  num = (sentry.GetValue(sentry2_vision_e.kVisionColor, sentry_obj_info_e.kStatus))  # Sentry/Sengo系列设置参数与输出结果的编号均从1开始  i = 1  for index in range(num):    rgb[0] = (0*brightness//9, 0*brightness//9, 255*brightness//9)    rgb.write()    if (i < 10):      oled.DispChar((str("Point#") + str(((str(i))[0:1]))), 0, (2-1)*16, 1)    else:      oled.DispChar((str("Point#") + str(((str(i))[0:2]))), 0, (2-1)*16, 1)    if (sentry.GetValue(sentry2_vision_e.kVisionColor,sentry_obj_info_e.kLabel,i)==color_label_e.kColorBlack):      oled.DispChar("Color: Black", 0, (3-1)*16, 1)    if (sentry.GetValue(sentry2_vision_e.kVisionColor,sentry_obj_info_e.kLabel,i)==color_label_e.kColorWhite):      oled.DispChar("Color: White", 0, (3-1)*16, 1)    if (sentry.GetValue(sentry2_vision_e.kVisionColor,sentry_obj_info_e.kLabel,i)==color_label_e.kColorRed):      oled.DispChar("Color: Red", 0, (3-1)*16, 1)    if (sentry.GetValue(sentry2_vision_e.kVisionColor,sentry_obj_info_e.kLabel,i)==color_label_e.kColorGreen):      oled.DispChar("Color: Green", 0, (3-1)*16, 1)    if (sentry.GetValue(sentry2_vision_e.kVisionColor,sentry_obj_info_e.kLabel,i)==color_label_e.kColorBlue):      oled.DispChar("Color: Blue", 0, (3-1)*16, 1)    if (sentry.GetValue(sentry2_vision_e.kVisionColor,sentry_obj_info_e.kLabel,i)==color_label_e.kColorYellow):      oled.DispChar("Color: Yellow", 0, (3-1)*16, 1)    oled.show()    i = (i + 1)    time.sleep(0.2)    oled.fill_rect(0, (2-1)*16, 128, 16, 0)    oled.fill_rect(0, (3-1)*16, 128, 16, 0)    oled.show()    rgb[0] = (0*brightness//9, 0*brightness//9, 0*brightness//9)    rgb.write()    time.sleep(0.2)def Param_Set1():  global my_variable, row, column, x, y, i, j, index, Paramset_Sel, Param_Set, num, Key_B  sentry.SetParamNum(sentry2_vision_e.kVisionColor,2)  # sentry/sengo系列视觉传感器采用相对坐标系，处理的图片分辨率之比为4:3，因此设置的宽度与高度值之比满足3:4，识别区域才为正方形；设置的宽度与高度相等，识别区域为长方形  sentry.SetParam(sentry2_vision_e.kVisionColor,[25, 25, 9, 12, 0],1)  sentry.SetParam(sentry2_vision_e.kVisionColor,[75, 75, 9, 12, 0],2)def Param_Set2():  global my_variable, row, column, x, y, i, j, index, Paramset_Sel, Param_Set, num, Key_B  sentry.SetParamNum(sentry2_vision_e.kVisionColor,(row * column))  # 切换行  for i in range(1, (row + 1), 1):    y = (round((i * (100 / (row + 1)))))    # 切换列    for j in range(1, (column + 1), 1):      x = (round((j * (100 / (column + 1)))))      index = (j + (row * (i - 1)))      # 设置25个识别点      sentry.SetParam(sentry2_vision_e.kVisionColor,[x, y, 6, 8, 0],index)      time.sleep(0.1)# 事件回调函数def on_button_a_down(_):  time.sleep_ms(10)  if button_a.value() == 1: return  global Param_Set  Param_Set = 1button_a.irq(trigger=Pin.IRQ_FALLING, handler=on_button_a_down)num = 0# 设置识别点的总行数，根据需要自行修改row = 5# 设置识别点的总列数，根据需要自行修改column = 5x = 0y = 0i = 0j = 0Param_Set = 0Paramset_Sel = 0index = 0# 等待Sentry2完成操作系统的初始化。此等待时间不可去掉，避免出现Sentry2尚未初始化完毕主控器已经开发发送指令的情况time.sleep(2)I2C()# 算法的默认参数，如果不用更改，则可以去掉本代码块sentry.SetParamNum(sentry2_vision_e.kVisionColor,1)# 算法的默认参数，如果不用更改，则可以去掉本代码块sentry.SetParam(sentry2_vision_e.kVisionColor,[50, 50, 3, 4, 0],1)# 1、算法介绍# https://tosee.readthedocs.io/zh/latest/Sentry2/Vision/index.html#chapter-vision-color-index# 2、参考视频# https://www.bilibili.com/video/BV18K411Z7Gh/?spm_id_from=333.1387.upload.video_card.click&vd_source=a6a4a13d17ed26ee248472534a8ec3cc# https://www.bilibili.com/video/BV1pP411s7zR/?spm_id_from=333.1387.homepage.video_card.click&vd_source=a6a4a13d17ed26ee248472534a8ec3cc# 3、环境光对颜色识别与色块检测算法的影响极大：过亮会导致过曝，识别到的颜色均为白色；过暗会导致识别的颜色均为黑色。这两种算法在使用时注意以下几点：# a.出厂默认的“自动”白平衡模式可以满足多数应用需求；# 存在大面积单色（非白色）区域，近距离识别颜色时，图像会发生偏色问题，可以通过摇杆操作或者发送代码设置白平衡模式为“锁定”，操作时需要将sentry2对准白色面，距离10-20cm；# 如果通过代码修改白平衡模式，命令发出后，延时至少500ms，等待设置生效；# 设置白平衡为“锁定”模式且经过白平衡校正操作，重启Sentry2参数依然有效；如果环境光发生改变，需要重新执行白平衡锁定操作。# b.环境过暗时，增加曝光时间在一定程度上可以缓解，但会算法增加检测识别的时间；最有效的方法是进行补光，Sentry2摄像头两侧的LED灯“检测到”与“未检测到”两种情况均设置为白光并且亮度调到最大值可以作为补光灯使用；# c.环境过亮时，降低曝光时间在一定程度上可以缓解；最有效的方法是降低环境光亮度以及避免采用易反光的材料做为地图或者目标物体；# d.当目标物体的颜色较淡时，可以增加成像的饱和度；# “设置LED灯光颜色”与“摄像头设置”请参考如下资料# https://tosee.readthedocs.io/zh/latest/Sentry2/Hardware/index.html#section-6# 4、正常使用时，应由主控器发送指令控制Sentry2算法的开启与关闭，而非通过摇杆手动进行操作；# 5、如需Sentry2启动后，自行运行某种算法，可以在开启算法后，通过设置“寄存器”->“保存当前值”实现。# 设置寄存器# https://tosee.readthedocs.io/zh/latest/Sentry2/Hardware/index.html#section-3sentry.VisionBegin(sentry2_vision_e.kVisionColor)oled.DispChar("Algo: Color", 0, (1-1)*16, 1)oled.show()while True:  if (Param_Set == 1):    Param_Set = 0    if (Paramset_Sel == 0):      Param_Set1()      Paramset_Sel = 1    else:      Param_Set2()      Paramset_Sel = 0    oled.DispChar("Operation Done!", 0, (4-1)*16, 1)    oled.show()    time.sleep(0.5)    oled.fill_rect(0, (4-1)*16, 128, 16, 0)    oled.show()  Result_Display()