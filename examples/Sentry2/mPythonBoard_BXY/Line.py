import timefrom Sentry import *from mpython import *from machine import UARTuart2 = UART(2, baudrate=57600, tx=Pin.P14, rx=Pin.P13)sentry = Sentry2(0x60)brightness=9# 自定义函数def UART():  global my_variable, i, Start, angle  sentry.begin(uart2)def I2C():  global my_variable, i, Start, angle  sentry.begin(i2c)def Result_Display():  global my_variable, i, Start, angle  # Sentry2不主动返回检测识别结果，需要主控板发送指令进行读取。读取的流程：首先读取识别结果的数量，接收到指令后，Sentry2会刷新结果数据，如果结果数量不为零，那么主控再发送指令读取结果的相关信息。请务必按此流程构建程序。  if ((sentry.GetValue(sentry2_vision_e.kVisionLine, sentry_obj_info_e.kStatus)) > 0):    # 按照默认设置只巡一条线，所以只需要读取结果1的信息并进行处理即可    angle = (sentry.GetValue(sentry2_vision_e.kVisionLine,sentry_obj_info_e.kLabel,1))    oled.DispChar((str("angle=") + str(angle)), 0, (2-1)*16, 1)    if (45 > angle):      Hard_Right()    if ((80 > angle) and (angle > 45)):      Right()    if ((100 > angle) and (angle > 80)):      Go_Straight()    if ((135 > angle) and (angle > 100)):      Left()    if (angle > 135):      Hard_Left()    oled.show()    time.sleep(0.2)    oled.fill_rect(0, (2-1)*16, 128, 16, 0)    oled.fill_rect(0, (3-1)*16, 128, 16, 0)    oled.show()def Go_Straight():  global my_variable, i, Start, angle  oled.DispChar("Go Straight", 0, (3-1)*16, 1)def Left():  global my_variable, i, Start, angle  oled.DispChar("Left", 0, (3-1)*16, 1)def Right():  global my_variable, i, Start, angle  oled.DispChar("Right", 0, (3-1)*16, 1)def Hard_Left():  global my_variable, i, Start, angle  oled.DispChar("Hard Left", 0, (3-1)*16, 1)def Hard_Right():  global my_variable, i, Start, angle  oled.DispChar("Hard Right", 0, (3-1)*16, 1)# 事件回调函数def on_button_a_down(_):  time.sleep_ms(10)  if button_a.value() == 1: return  global Start  Start = 1def on_button_b_down(_):  time.sleep_ms(10)  if button_b.value() == 1: return  global Start  Start = 0button_a.irq(trigger=Pin.IRQ_FALLING, handler=on_button_a_down)button_b.irq(trigger=Pin.IRQ_FALLING, handler=on_button_b_down)angle = 0Start = 0# 等待Sentry2完成操作系统的初始化。此等待时间不可去掉，避免出现Sentry2尚未初始化完毕主控器已经开发发送指令的情况time.sleep(2)I2C()# 1、算法文档# https://tosee.readthedocs.io/zh/latest/Sentry2/Vision/index.html#chapter-vision-line-index# 2、算法视频# https://www.bilibili.com/video/BV1de4y137QU/?spm_id_from=333.1387.upload.video_card.click&vd_source=a6a4a13d17ed26ee248472534a8ec3cc# 3、请保持默认设置：只检测一条线段# 4、正常使用时，应由主控器发送指令控制Sentry2算法的开启与关闭，而非通过摇杆手动进行操作；# 5、如需Sentry2启动后，自行运行某种算法，可以在开启算法后，通过设置“寄存器”->“保存当前值”实现。# 设置寄存器# https://tosee.readthedocs.io/zh/latest/Sentry2/Hardware/index.html#section-3sentry.VisionBegin(sentry2_vision_e.kVisionLine)oled.DispChar("Algo:Line", 0, (1-1)*16, 1)oled.show()while True:  rgb[1] = (0*brightness//9, 0*brightness//9, 255*brightness//9)  rgb.write()  Result_Display()  rgb[1] = (0*brightness//9, 0*brightness//9, 0*brightness//9)  rgb.write()  time.sleep(0.2)